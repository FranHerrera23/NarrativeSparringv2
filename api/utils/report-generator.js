/**
 * REPORT GENERATOR MODULE
 * Narrative Sparring - Convert markdown reports to PDF
 *
 * Converts Claude-generated markdown to branded PDF documents
 */

const markdownPdf = require('markdown-pdf');
const { jsPDF } = require('jspdf');
const { Readable } = require('stream');

/**
 * Convert markdown report to PDF
 * @param {string} markdown - The markdown content from Claude
 * @param {Object} options - Generation options
 * @returns {Promise<Buffer>} - PDF buffer
 */
async function generatePDF(markdown, options = {}) {
  const {
    title = 'Narrative Sparring Report',
    author = 'CRUDA',
  } = options;

  return new Promise((resolve, reject) => {
    try {
      // Create a readable stream from markdown string
      const markdownStream = Readable.from([markdown]);

      // Buffer to collect PDF chunks
      const chunks = [];

      // Configure markdown-pdf with custom styling
      const pdfOptions = {
        cssPath: null, // We'll use inline CSS
        remarkable: {
          html: true,
          breaks: true,
        },
        paperFormat: 'Letter',
        paperOrientation: 'portrait',
        paperBorder: '2cm',
        renderDelay: 100,
        preProcessMd: (md) => addBranding(md, title),
      };

      // Generate PDF
      markdownStream
        .pipe(markdownPdf(pdfOptions))
        .on('data', (chunk) => chunks.push(chunk))
        .on('end', () => {
          const pdfBuffer = Buffer.concat(chunks);
          resolve(pdfBuffer);
        })
        .on('error', (error) => {
          reject(new Error(`PDF generation failed: ${error.message}`));
        });

    } catch (error) {
      reject(new Error(`PDF setup failed: ${error.message}`));
    }
  });
}

/**
 * Add CRUDA branding to markdown
 */
function addBranding(markdown, title) {
  const header = `---

# ${title}

**Diagnostic by CRUDA | Narrative Sparring**

---

`;

  const footer = `

---

*This report was generated by CRUDA's narrative diagnostic engine.*
*Questions? Contact us at support@cruda.io*

---
`;

  return header + markdown + footer;
}

/**
 * Simpler alternative: Generate HTML instead of PDF
 * (In case markdown-pdf has issues, we can use this as fallback)
 */
function generateHTML(markdown, options = {}) {
  const {
    title = 'Narrative Sparring Report',
  } = options;

  const html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
      line-height: 1.6;
      max-width: 800px;
      margin: 0 auto;
      padding: 40px 20px;
      color: #333;
    }
    h1 {
      font-size: 32px;
      font-weight: 700;
      margin-bottom: 10px;
      color: #000;
    }
    h2 {
      font-size: 24px;
      font-weight: 600;
      margin-top: 40px;
      margin-bottom: 15px;
      color: #000;
      border-bottom: 2px solid #000;
      padding-bottom: 5px;
    }
    h3 {
      font-size: 18px;
      font-weight: 600;
      margin-top: 30px;
      margin-bottom: 10px;
      color: #222;
    }
    p {
      margin-bottom: 15px;
    }
    ul, ol {
      margin-bottom: 15px;
      padding-left: 30px;
    }
    li {
      margin-bottom: 8px;
    }
    blockquote {
      border-left: 4px solid #ddd;
      padding-left: 20px;
      margin-left: 0;
      color: #666;
      font-style: italic;
    }
    .header {
      text-align: center;
      border-bottom: 3px solid #000;
      padding-bottom: 20px;
      margin-bottom: 40px;
    }
    .footer {
      text-align: center;
      border-top: 2px solid #ddd;
      padding-top: 20px;
      margin-top: 60px;
      color: #666;
      font-size: 14px;
    }
    code {
      background: #f4f4f4;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
    }
    pre {
      background: #f4f4f4;
      padding: 15px;
      border-radius: 5px;
      overflow-x: auto;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>${title}</h1>
    <p><strong>Diagnostic by CRUDA | Narrative Sparring</strong></p>
  </div>

  ${convertMarkdownToHTML(markdown)}

  <div class="footer">
    <p><em>This report was generated by CRUDA's narrative diagnostic engine.</em></p>
    <p>Questions? Contact us at support@cruda.io</p>
  </div>
</body>
</html>`;

  return html;
}

/**
 * Basic markdown to HTML converter
 * (Simple implementation for fallback)
 */
function convertMarkdownToHTML(markdown) {
  let html = markdown;

  // Headers
  html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
  html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
  html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');

  // Bold
  html = html.replace(/\*\*(.*?)\*\*/gms, '<strong>$1</strong>');

  // Italic
  html = html.replace(/\*([^*\n]+)\*/g, '<em>$1</em>');

  // Links
  html = html.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2">$1</a>');

  // Paragraphs
  html = html.replace(/\n\n/g, '</p><p>');
  html = '<p>' + html + '</p>';

  // Clean up empty paragraphs
  html = html.replace(/<p><\/p>/g, '');
  html = html.replace(/<p>\s*<\/p>/g, '');

  return html;
}

/**
 * Generate PDF using jsPDF (serverless-compatible, pure JavaScript)
 * @param {string} markdown - The markdown content from Claude
 * @param {Object} options - Generation options
 * @returns {Promise<Buffer>} - PDF buffer
 */
async function generatePDFKit(markdown, options = {}) {
  const {
    title = 'Narrative Sparring Diagnostic Report',
    author = 'CRUDA',
  } = options;

  try {
    const doc = new jsPDF({
      orientation: 'portrait',
      unit: 'pt',
      format: 'letter',
    });

    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const margin = 50;
    const maxWidth = pageWidth - (margin * 2);
    let yPos = margin;

    // Helper to add page if needed
    const checkPageBreak = (neededSpace = 20) => {
      if (yPos + neededSpace > pageHeight - margin) {
        doc.addPage();
        yPos = margin;
      }
    };

    // Add CRUDA branding header
    doc.setFontSize(24);
    doc.setFont('helvetica', 'bold');
    doc.text('CRUDA', pageWidth / 2, yPos, { align: 'center' });
    yPos += 30;

    doc.setFontSize(14);
    doc.setFont('helvetica', 'normal');
    doc.text('Narrative Sparring', pageWidth / 2, yPos, { align: 'center' });
    yPos += 20;

    // Draw line
    doc.setLineWidth(2);
    doc.line(margin, yPos, pageWidth - margin, yPos);
    yPos += 30;

    // Add title
    doc.setFontSize(18);
    doc.setFont('helvetica', 'bold');
    doc.text(title, pageWidth / 2, yPos, { align: 'center' });
    yPos += 40;

    // Parse and add markdown content
    const lines = markdown.split('\n');

    for (let i = 0; i < lines.length; i++) {
      let line = lines[i].trim();

      // Skip empty lines
      if (!line) {
        yPos += 10;
        checkPageBreak();
        continue;
      }

      // Headers
      if (line.startsWith('# ')) {
        checkPageBreak(30);
        doc.setFontSize(20);
        doc.setFont('helvetica', 'bold');
        const text = line.substring(2);
        const splitText = doc.splitTextToSize(text, maxWidth);
        doc.text(splitText, margin, yPos);
        yPos += splitText.length * 25;
        continue;
      }

      if (line.startsWith('## ')) {
        checkPageBreak(25);
        doc.setFontSize(16);
        doc.setFont('helvetica', 'bold');
        const text = line.substring(3);
        const splitText = doc.splitTextToSize(text, maxWidth);
        doc.text(splitText, margin, yPos);
        yPos += splitText.length * 20;
        continue;
      }

      if (line.startsWith('### ')) {
        checkPageBreak(20);
        doc.setFontSize(14);
        doc.setFont('helvetica', 'bold');
        const text = line.substring(4);
        const splitText = doc.splitTextToSize(text, maxWidth);
        doc.text(splitText, margin, yPos);
        yPos += splitText.length * 18;
        continue;
      }

      // Bold text (simple detection)
      const isBold = line.includes('**');
      const cleanLine = line.replace(/\*\*/g, '');

      checkPageBreak(15);
      doc.setFontSize(11);
      doc.setFont('helvetica', isBold ? 'bold' : 'normal');
      const splitText = doc.splitTextToSize(cleanLine, maxWidth);
      doc.text(splitText, margin, yPos);
      yPos += splitText.length * 15;
    }

    // Add footer on last page
    yPos = pageHeight - margin - 30;
    doc.setLineWidth(1);
    doc.line(margin, yPos, pageWidth - margin, yPos);
    yPos += 15;

    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.text('This report was generated by CRUDA\'s narrative diagnostic engine.', pageWidth / 2, yPos, { align: 'center' });
    yPos += 15;
    doc.text('Questions? Contact us at support@cruda.io', pageWidth / 2, yPos, { align: 'center' });

    // Convert to buffer
    const pdfArrayBuffer = doc.output('arraybuffer');
    return Buffer.from(pdfArrayBuffer);

  } catch (error) {
    throw new Error(`PDF generation failed: ${error.message}`);
  }
}

module.exports = {
  generatePDF,
  generateHTML,
  generatePDFKit,
};
